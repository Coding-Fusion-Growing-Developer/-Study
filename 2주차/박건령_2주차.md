## 1. 데이터 모델링 이론

### 관계형 데이터 모델 이론

관계형 데이터 모델
- 데이터를 2차원 테이블(표) 형식으로 정의하고 표현한 모델
- 이런 테이블 형태를 릴레이션이라고 함

릴레이션
- 릴레이션은 스키마(헤더)와 실제 값인 인스턴스(본문)으로 구성
- 릴레이션 스키마는 릴레이션명과 어트리뷰트를 포함

튜플
- 튜플은 릴레이션 인스턴스에 해당(row)
- 릴레이션의 튜플은 모두 다른 값을 가지며 중복된 튜플을 허용하지 않는다.
- 튜플들의 순서와 무관하며 순서가 특별한 의미를 가지지 않는다.

어트리뷰트
- 어트리뷰트는 릴레이션을 구성하는 각 열을 의미(column)
- 어트리뷰트는 더 쪼갤 수 없는 원자 값으로 구성되며, 튜플 순서처럼 어트리뷰트 순서도 의미를 가지지 않는다.
- 어트리뷰터 명칭은 서로 다르며 유일하지만, 어트리뷰트 값은 동일해도 상관 없다.

관계형 모델의 키
- 슈퍼 키(Super Key)
  - 튜플을 고유하게 식별할 수 있는 속성 집합
  - 릴레이션은 한 개 이상의 슈퍼 키를 가질 수 있으며, 슈퍼 키 값은 모든 튜플에서 유일해야 한다.
  - ex) 사원번호, {사원번호, 사원명} (고유하게 식별할 수만 있다면 된다.)
- 후보 키(Candidate Key)
  - 튜플을 고유하게 식별할 수 있는 최소한의 속성 집합
  - ex) 슈퍼 키 사원번호, {사원번호, 사원명} 중 최소한의 값인 사원번호가 후보키이다.
  - 모든 후보 키는 슈퍼 키 이지만, 모든 슈퍼 키가 후보 키는 아니다.(슈퍼 키가 더 큰 개념)
- 기본 키(Primary Key)
  - 릴레이션은 하나 이상의 후보 키가 있을 수 있고, 그 중 하나만이 기본 키가 될 수 있다.
  - 후보 키와 마찬가지로 유일성, 최소성을 가짐
- 대체 키(Alternate Key)
  - 후보 키 중 기본 키가 아닌 후보 키
  - ex) 후보 키 {사원번호, 전화번호} 중 사원번호를 기본 키로 정의했으므로 전화번호는 대체 키
- 외래 키(Foreign Key)
  - 릴레이션의 어트리뷰트 값이 다른 릴레이션의 기본 키를 참조하는 경우
  - 외래 키는 Null이 될 수 있고, 중복된 튜플을 가질 수 있다.
  - ex) 사원자격증 릴레이션에서 사원번호는 사원 릴레이션의 기본 키인 사원번호를 참조하며, 사원자격증 릴레이션 내에서 유일하지 않다.(사원자격증이 여러개일 수 있다.)

제약조건
- 키 제약조건
  - 키는 사원의 사원번호처럼 튜플을 유일하게 식별할 수 있는 어트리뷰트들로 구성하며, 다른 튜플의 키 값과 중복된 값이 있어서는 안된다.(Unique)
- 무결성 제약조건
  - 실체 무결성
    - 주문상품의 주문번호, 상품번호처럼 릴레이션의 기본키를 구성하는 모든 어트리뷰트는 Null 값이 아니어야 하고, 릴레이션 내에서 오직 하나의 값만 존재해야 한다.(Not Null, Unique)
  - 영역 무결성
    - 주문수량이 소수점을 포함하지 않는 정수 값인 것처럼 릴레이션 내의 각 어트리뷰트 값은 반드시 정의된 도메인에 속한 값이어야 한다.(필드 타입 준수)
  - 참조 무결성
    - 사원의 부서코드는 부서의 부서코드에 모두 존재하는 값인 것처럼 자식 릴레이션의 외래키는 참조하는 부모 릴레이션의 기본키 값 이외의 값을 가질 수 없으며, 두 릴레이션 값의 일관성을 유지해야 한다.

함수 종속
- 관계형 데이터모델은 수학적인 이론을 바탕으로 하며, 관계형이라는 용어 자체가 수학의 집합론(Set Theory)의 관계형 이론(Relational theory)으로 부터 유래하였다.
- 관계형 데이터베이스를 설계할 때 정규화 과정을 거치게 되는데, 이 때 함수 종속성 개념이 중요하게 사용된다.

함수 종속성
- 일종의 무결성 제약조건으로, 키의 개념을 일반화한 것
- 어떤 릴레이션 R에서 속성 X의 값 각각에 대해 속성 Y의 값이 오직 하나만 연관되어 있을 때 Y는 X에 함수적으로 종속되어 있다고 하고, X -> Y로 표시한다. X의 속성 값이 Y의 속성 값을 결정하며 이때 X를 결정자(Determinant)라 하고, Y를 종속자(dependent)라고 한다.
- ex) "고객" 테이블에서 고객번호, 고객명, 생년월일, 전화번호, 주소 속성을 가지고 있을 때, 고객번호 컬럼에 다른 컬럼들이 함수적으로 종속된다. 고객번호 -> (고객명, 생년월일, 전화번호, 주소)
- <b>다시말하면, 함수 종속성은 테이블의 특정 컬럼 A의 값을 알게되면 다른 컬럼 B의 값을 알 수 있을 때, 컬럼 B는 컬럼 A에 함수적 종속성이 있다고 한다. 고객번호를 알면 고객명을 알 수 있으며, '고객명은 고객번호에 대해 함수적 종속성이 있다' 라고 말한다.</b>

- 함수 종속성의 종류
  - 완전 함수종속(Full Functional Dependency)
    - 임의의 릴레이션 R에서 속성 또는 속성들의 집합 X에 대해 Y가 함수적으로 종속되나, X의 부분집합에 대해서는 함수적으로 종속하지 않은 경우, Y는 X에 대하여 완전 함수 종속성을 갖는다고 한다.
    - ex) 주문내역의 기본키가 주문번호와 상품 코드로 구성된 경우 주문 수량은 주문번호 또는 상품코드에 종속되는 것이 아니라 주문번호, 상품코드 조합에 종속되므로 주문번호, 상품코드와 완전함수종속성을 갖는다.
    - 제1정규형과 관계가 있다.
  - 부분 함수종속(Partial Functional Dependency)
    - 완전하게 함수적으로 종속하지 않으면, 부분 함수종속성을 갖는다. 여러개의 속성이 모여서 하나의 기본키를 이룰 경우, 기본키를 구성하는 일부 속성만으로도 종속관계가 결정되면 부분 함수종속이라고 한다.
    - ex) 상품단가는 기본키인 주문번호, 상품코드의 일부인 상품코드에 의해 결정되며, 기본키인 주문번호, 상품코드에 부분 함수종속성을 가진다.
    - 제2정규형과 관련이 있다. 
  - 이행적 함수종속(Transitive Functional Dependency)
    - 함수종속관계 X -> Y와 Y -> Z가 성립되면, 논리적 결과로 X -> Z가 성립한다. 이 때 속성 Z는 X에 이행적 함수종속성을 갖는다. 이행적 함수종속은 데이터 변경 이상의 원인이 된다.
    - ex) 주문번호를 알면 고객번호를 알 수 있고(주문번호 -> 고객번호), 고객번호를 알면 고객명을 알 수 있으므로(고객번호 -> 고객명), 주문번호를 알면 고객명을 알 수 있다.(주문번호 -> 고객명)
    - 제3정규형과 관련이 있다.

정규화(Normalization)
- 함수적 종속성과 같은 이론에 근거하여 관계형 데이터베이스의 테이블에 대해 데이터를 입력, 수정, 삭제할 때 발생하는 이상 현상을 최소화하기 위해 좀 더 작은 단위의 테이블로 설계하는 과정
- 정규화의 장점
  1. 데이터를 입력, 수정, 삭제하는 과정에서 발생하는 이상 현상을 최소화할 수 있다.
  2. 상호 종속성이 강한 데이터 요소들을 분리하여 독립된 개념(엔티티)으로 정의함에 따라 높은 응집력과 낮은 결합도 원칙에 충실하면서, 데이터 구조 변경 시 유연성이 증가한다(유연성 극대화).예를 들어, 고객정보에 계좌정보가 포함된 구조보다 고객과 계좌가 별도로 분리된 경우, 고객과 계좌가 1:1 또는 1:M 관계를 가지게 되어 현업의 다양한 요구사항에 대해 데이터 모델 변경을 최소화하면서 업무 요건을 수용할 수 있다.
  3. 개념을 좀 더 작은 단위로 세분할 경우 해당 개념에 대한 재활용성이 높아진다. 일반적으로 각종 참조 모델(Reference Model)은 정규형을 만족하고 있다.
  4. Non-key 데이터 요소가 한번만 표현됨에 따라 중복을 최소화하고(중복 최소화), 데이터 품질 문제를 줄일 수 있으며, 저장공간을 최소화할 수 있다.
  5. 데이터 입력, 수정, 삭제에 대한 작업을 최소화하여 수행속도가 향상된다.
- 데이터 모델링은 일반적으로 각각의 엔티티, 속성, 관계에 대한 업무적인 개념을 정의하는 과정이며, 각각의 개념은 다른 개념과 독립적인 성격으로 설계되기 때문에 데이터 모델링의 결과로 도출되는 데이터 모델(ERD)은 이미 정규화된 형태를 가진다.
- 정규형을 만족하지 못하는 모델은 '개념'이 명확하지 않거나 혹은 다수의 '개념'을 하나의 엔티티에 포함한 것 -> 개념을 분리하여 모델링을 하면 대부분 정규형을 만족하는 결과를 얻음
- 리버스 모델링을 중심으로 상향식 모델링을 진행할 경우, 현행 데이터 모델이 정규형을 만족하는지 검토해 개선점을 도출하기 위한 용도로 사용 가능
- 정규화를 너무 심하게 할 경우, 응용 프로그램에서 조인(Join)이 빈번하게 발생해 성능이 저하되지 않을까 걱정할 수 있다.
- Join이 발생하는 것은 맞지만, 이로 인해 반드시 성능 문제가 발생한다고 볼 수는 없다. 성능이 저하되는 문제는 조인이 원인이라기보다는 데이터베이스 특성을 고려하지 않고 사용할 때 발생하는 경우가 더 많다.
- 때로는 반정규화를 하기도 하는데, 이 경우도 매우 제한적으로 사용해야 하고, 데이터 중복으로 인한 각종 이상현상이 발생하지 않도록 많은 노력을 기울여야 한다.


제1정규형(1NF)
- 제1정규형에 대한 기준은 학자마다 조금씩 다르지만, 가장 일반적인 특징은 중복되는 행이 없어야 하고, 모든 열의 값은 원자값을 가져야 한다는 것
- 중복 행은 키와 관련되어 있고, 행이 중복되지 않도록 기본 키를 지정해야 한다. 테이블의 모든 열 값이 단일 값이 되려면 개념적으로 중복 열이 없어야 하고, 다중 값이 발생하지 않아야 한다.
- 개념적으로 중복되는 열은 전화번호1, 전화번호2 처럼 동일한 개념의 어트리뷰트가 여러 개 있는 형태
- 다중 값은 "02-1111-1111, 02-2222-2222"와 같은 형태
- 중복 어트리뷰트이거나, 다중 값을 가지는 어트리뷰트는 별도 릴레이션(테이블)로 분리해야 한다.
- ex) 상품코드, 상품명, 상품단가, 주문 수량은 하나의 주문에 대해 다수 개의 값(다중 값, Multivalue)을 가질 수 있으므로 분리해야 하며, 정규화에 의해 분리된 테이블(예, 주문내역)은 일반적으로 원래 테이블의 기본키를 상속하며 해당 테이블의 기본키로 정의한다.
- 분리된 컬럼 중에서 나머지 컬럼을 유일하게 식별할 수 있는 컬럼(예, 상품코드)이 있으면 이를 기본키로 추가하고, 그렇지 않으면 대체 키를 추가하여 설계한다.

제2정규형(2NF)
- 제1정규형을 만족하고, 키가 아닌 어트리뷰트(후보키에 속하지 않는 속성)는 후보키 전체에 종속되어야 한다.
- 즉, 후보키에 종속적이지 않거나 후보키 일부 어트리뷰트에 종속적인 어트리뷰트는 별도 릴레이션(테이블)로 분리해야 한다.
- 주문내역에서 상품명, 상품단가는 기본키인 주문번호, 상품코드 전체에 종속되어 있는 것이 아니라 기본키의 일부인 상품코드에 종속되어 있다.
- 제2정규형을 만족하기 위해 별도 테이블인 상품 테이블을 추가하고, 컬럼을 상품 테이블로 분리해야 한다. 이때 상품코드를 상품 테이블의 기본키로 지정한다.

제3정규형(3NF)
- 제2정규형을 만족하고, 키가 아닌 어트리뷰트들 간에는 서로 종속적인 관계가 없어야 한다.
- 즉, 키가 아닌 어떤 어트리뷰트가 다른 어트리뷰트에 종속된 경우 별도 릴레이션으로 분리해야 한다.
- 주문 테이블에서 고객명, 고객전화번호는 기본키가 아닌 고객번호에 종속되어 있으므로 별도 테이블(고객)로 분리해야 한다. 이때 분리된 테이블의 기본키로 고객번호(결정자)를 지정한다.

연결함정(Connection Trap)
- 관계형 모델에서 모호한 관계가 발생하는 현상
- 정규화 과정에서 무손실 분해의 원칙이 지켜지지 않아 원래 있던 관계성을 잃어버리는 현상
- 엔티티와 엔티티 사이에 부여하는 관계성 집합의 의미가 모호하여 원하는 결과를 얻을 수 없거나, 엔티티 간의 관계가 불분명해지거나 업무적인 연관성이 모호해지는 것이다.
- 일반적으로 세 엔티티 사이의 삼항관계(ternary relationship)를 두 엔티티 간의 이항관계(Binary Relationship)로 분할하여 표현한다.
- 이때 삼항관계를 이항관계로 분할하면서 원래 삼항관계 릴레이션을 재현하지 못하게 될 때 연결함정이 발생한다.
- 연결함정은 관계의 모호성 형태에 따라 부채꼴 함정(Fan Trap)과 균열함정(Chasm Trap)으로 나눌 수 있다.

부채꼴 함정(Fan Trap)
- 엔티티 사이의 관계가 정의되어 있지만, 관계가 모호할 때가 있다.
- M:N 관계를 해결하기 위해 교차 엔티티를 추가하면서 1:M 관계를 만들 때 나타날 수 있다. 엔티티 간의 관계를 잘못 설계하여 연계된 정보를 추적하지 못해 발생하므로, 이들 간의 관계를 명확히 하여 해결할 수 있다.
- 회사에서 물품을 구매한 공급사를 관리하고, 여러 상품을 구매한다고 가정해보자. 이들 간의 관계를 공급사와 회사, 회사와 물품의 관계로 표현했을 때 해당 물품이 어느 공급사에서 구매한 것인지 알 수 없는 문제가 발생한다.
- 회사와 공급사 간의 관계와 공급사와 물품 간의 관계로 변환하여, 이들 간의 관계를 다시 명확하게 표현하도록 ER 모델을 재구성할 수 있다.

균열 함정(Chasm Trap)
- 엔티티 사이에 관계가 정의되어 있지만, 일부 엔티티와 엔티티 사이의 관계가 존재하지 않는 경우에 발생한다. 이 경우 일부 누락된 관계를 추가하여 해결할 수 있다.
- 중복된 관계를 제거할 때 정말 중복된 것인지 중복된 것처럼 느껴지는 것인지 다시 한번 확인할 필요가 있다.

### 데이터 모델링 접근방법

변화하는 기업환경과 기술발전에 유연하고 신속하게 대처하기 위해서는 사업에 필요한 본질적인 정보를 체계적으로 잘 구축하고 변화에 적응하기 위한 데이터 아키텍처가 필수적이다.
데이터모델은 데이터 아키텍처의 핵심 구성요소다. 조직의 목표를 달성하고, 조직을 관리 운영하기 위해 필요한 데이터를 식별하고 데이터 자산을 효율적으로 관리하기 위한 틀을 제공한다.

데이터 모델링은 프로젝트 상황에 따라 하향식 / 상향식 접근방식을 선택하거나 적절히 섞어서 진행할 수 있다.

하향식 접근
- 전체 데이터를 큰 개념으로 분할하고 업무 담당자별로 단위 개념을 식별하면서 정의해나가는 방식
- 개념 모델링 -> 논리 모델링 -> 물리 설계 순으로 상세화 하면서 진행
- 프로젝트 규모가 크고 업무 영역별로 현업 또는 전산 담당자가 있어 업무 지원이 원활한 경우 이용
- 현업과 게속 의사소통하면서 모델링 과정을 같이 진행하므로 나중에 결과물에 대한 의견 일치 및 소유감이 높고 다른 업무영역의 문제 제기에 대해 적극적인 도움을 받을 수 있다.

상향식 접근
- 업무 단위의 프로젝트 등 규모가 작거나 현업의 참여가 한정된 경우
- ERD, 보고서, 매뉴얼, 업무 지침서 등을 통해 처리해야 할 데이터 항목을 조사한 후 이를 근거로 데이터 모델링
- 이 또한 모델링 과정을 현업을 포함한 업무 관련자와 공유하면서 진행해야 의견차나 설계 변경을 줄일 수 있다.

데이터 모델링
- 구축할 정보시스템에 대한 요구사항을 수집, 요구사항 및 현행 시스템의 데이터 구조를 분석해 문제점 및 개선 방향을 도출
- 개념 모델링 시 전체 데이터 영역을 대상으로 데이터 주제영역을 식별하고 정의하며, 높은 응집도 및 낮은 결합도 관점에서 주제영역을 세분화하고 핵심 엔티티 및 식별자를 도출하여 관계를 정의
- 논리 모델링 시 주제영역의 핵심 엔티티를 중심으로 업무와 관련된 모든 엔티티를 도출하고 속성과 관계를 식별하여 세부적인 데이터 모델을 완성하는 과정
- 모델 검토 및 검증과정을 거쳐 논리 모델이 완성되면 데이터베이스 특성을 고려해 엔티티를 테이블로, 속성을 컬럼으로 변환하고 관리적, 성능적 측면 등을 고려해 파티션이나 인덱스를 설계

현행 분석 및 방향성 수립
- 현행 분석은 현행 업무 분석과 현행 데이터 분석을 포함
- 현행 업무에 대한 기본적 지식 습득과 업무 파악을 통해 업무 특성이나 흐름을 파악하고, 문제점 및 개선방안을 도출
- 현행 데이터 분석
  - 현행 ERD, 테이블 정의서 등의 산출물을 수집하여 분석, 실제 데이터를 분석하거나 운영 담당자를 통해 데이터 구조나 성능적인 이슈를 중심으로 자료 분석
  - 요구사항 정의는 제안요청서나 제안서에 기술된 요구사항에 대해 데이터 모델링 관점에서 관련된 요구사항을 수집, 현업 및 운영담당자와 인터뷰를 통해 요구사항을 상세화하는 과정
  - 현행 분석 및 요구사항 정의를 통해 현행 시스템에 대한 현황 및 문제점을 도출하고, 목표 시스템에 대한 데이터 모델링 관점의 개선 및 설계 방향을 수립
  - 방향성 수립을 통해 큰 틀에서 현행 데이터 모델의 문제점을 개선하고, 요구사항을 반영하여 형상화한 개념적인 데이터 모델을 제시
- 현업 담당자와 협업
  - 현업이 모델링 과정을 전폭적으로 지원하므로 가장 좋은 접근 방법
  - 현업 담당자와 원활한 의사소통을 위해 모델러는 업무에 대한 기본적인 이해가 필수적(해당 조직에서 얻을 수 있는 문서를 참고해 최대한 빨리 업무 지식 쌓기)
  - 현업에게 ER 표기법 등의 모델링 교육을 사전에 진행할 필요가 있고, 진행 과정을 보면서 직접 모델링 과정에 참여시킬 수 있다
  - 현업 담당좌와 회의나 인터뷰를 진행하는 방법은 현업과 모델러, 현업과 응용설계자가 따로 진행하거나 모두 같이 진행하는 방법이 있다.
  - 따로 진행할 경우 관심있는 분야에 집중할 수 있지만, 현업 담당자 입장에서는 시간을 두배로 투자해야하고, 중복일 수 있다.
  - 같이 진행할 겨우 현업은 시간을 절약할 수 있으나, 모델러와 응용설계자는 집중도가 떨어지고 회의 시간이 길어지게 된다.
  - 프로젝트 상황을 고려해 적절히 협의하고 진행해야 한다.
- 문서를 통합 업무 요건 파악
  - 문서를 통해 데이터 요건을 수집하는 경우, 업무지침서, 과거 프로젝트 구축 산출물, 업무 메뉴얼 등 관련된 문서를 통해 업무나 데이터 구조를 파악한다.
  - 문서를 참고하되, 궁금한 사항, 확인이 필요한 사항을 질문 목록으로 만들어 현업과 대면이나 서면을 통해 답변을 얻는 것이 좋다.
- 리버스 모델 활용
  - 현행 ERD가 없거나 현행화가 이루어지지 않은 경우, 현행 시스템의 DB 메타정보를 이용해 ERD를 작성할 수 있다. 이 과정을 리버스 모델링이라 한다.
  - 리버스 시, 빠른 시간 내에 대상 시스템의 핵심 데이터 구조를 이해하고, 업무 흐름을 비교적 쉽게 파악할 수 있다.
  - 다만 리버스에 의존할 경우, 기존 데이터 모델에 얽매여 새로운 사고의 확장이 어렵고, 창의적인 개념에 대한 불안감이 커질 수 있다.
  - 리버스를 이용하여 빠르게 접근하되 새로운 관점에서 생각하는 습관이 필요하고, 현업의 지원이 필요하다.
- 리버스 모델링
  - 리버스 모델링 작업은 DB 메타 정보를 이용해 기초 데이터 모델을 생성(엔티티)하고, 컬럼에 대한 Comment나 시스템 운영자의 지원을 받아 속성명을 한글화한다.
  - 리버스 작업은 데이터 모델링 툴에서 제공하는 기능을 활용한다. 작업의 효율성을 위해 모델을 관리할 수 있는 단위로 나누어 진행한다.
  - 리버스 작업을 한번에 실행할 경우 반복하지 않아도 돼서 편리하지만, 엔티티 식별 및 관계 도출을 한번에 하는 것은 어렵기에 나눠서 진행하는 것이 효율적이다.
  - 리버스 작업 시 더이상 사용하지 않거나 쓸모없는 테이블을 작업하지 않기 위해 리버스 대상을 선별하는 작업도 매우 중요하다.(과감하게 제외해라. 어차피 중요한 테이블은 식별하게 되어있다.)
  - 리버스 대상을 정할 때, DB 메타 정보에서 테이블명 기준으로 백업, 임시테이블을 제외한 상태에서 DDL문을 생성해 리버스하는 방법이 더 효율적이다.
  - 작업 시, 엔티티가 너무 많아 보기 힘들 때는, 테이블명이 유사하거나 특정 컬럼이 들어있는 테이블을 선별해 한 곳으로 이동시켜 작업해라.
  - 리버스 모델링은 데이터 모델링 과정에서 아주 중요한 작업이다.